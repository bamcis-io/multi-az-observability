"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceAlarmsAndRules = void 0;
const constructs_1 = require("constructs");
//import { AlarmRule, CompositeAlarm, IAlarm } from "aws-cdk-lib/aws-cloudwatch";
const aws_cloudwatch_1 = require("aws-cdk-lib/aws-cloudwatch");
//import { Alarm, AlarmRule, ComparisonOperator, CompositeAlarm, IAlarm, IMetric, MathExpression } from "aws-cdk-lib/aws-cloudwatch";
const AvailabilityAndLatencyMetrics_1 = require("../metrics/AvailabilityAndLatencyMetrics");
const AvailabilityMetricType_1 = require("../utilities/AvailabilityMetricType");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const AvailabilityZoneMapper_1 = require("../utilities/AvailabilityZoneMapper");
/**
 * Service level alarms and rules using critical operations
 */
class ServiceAlarmsAndRules extends constructs_1.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        this.service = props.service;
        let criticalOperations = props.service.operations.filter(x => x.isCritical == true).map(x => x.operationName);
        let counter = 1;
        this.zonalAggregateIsolatedImpactAlarms = [];
        let azMapper = new AvailabilityZoneMapper_1.AvailabilityZoneMapper(this, "AZMapper", {
            availabilityZoneNames: props.service.availabilityZoneNames
        });
        for (let i = 0; i < props.service.availabilityZoneNames.length; i++) {
            let availabilityZonedId = azMapper.availabilityZoneId(props.service.availabilityZoneNames[i]);
            this.zonalAggregateIsolatedImpactAlarms.push(new aws_cloudwatch_1.CompositeAlarm(this, "AZ" + counter + "ServiceAggregateIsolatedImpactAlarm", {
                compositeAlarmName: availabilityZonedId + "-" + props.service.serviceName.toLowerCase() + "-isolated-impact-aggregate-alarm",
                alarmRule: aws_cloudwatch_1.AlarmRule.anyOf(...Object.values(Object.entries(props.perOperationAlarmsAndRules)
                    .reduce((filtered, [key, value]) => {
                    if (criticalOperations.indexOf(key) > -1) {
                        filtered[key] = value;
                    }
                    return filtered;
                }, {}))
                    .map(x => x.aggregateZonalAlarms[i]))
            }));
            counter++;
        }
        this.regionalAvailabilityServerSideAlarm = new aws_cloudwatch_1.CompositeAlarm(this, "tesT", {
            alarmRule: aws_cloudwatch_1.AlarmRule.fromString("ALARM(TEST)")
        });
        let keyPrefix = "";
        let regionalOperationFaultCountMetrics = {};
        props.service.operations.filter(x => x.isCritical == true).forEach(x => {
            keyPrefix = AvailabilityAndLatencyMetrics_1.AvailabilityAndLatencyMetrics.nextChar(keyPrefix);
            regionalOperationFaultCountMetrics[keyPrefix] = AvailabilityAndLatencyMetrics_1.AvailabilityAndLatencyMetrics.createRegionalAvailabilityMetric({
                label: x.operationName + " fault count",
                metricDetails: x.serverSideAvailabilityMetricDetails,
                metricType: AvailabilityMetricType_1.AvailabilityMetricType.FAULT_COUNT
            });
        });
        let regionalFaultCount = new aws_cloudwatch_1.MathExpression({
            usingMetrics: regionalOperationFaultCountMetrics,
            expression: Object.keys(regionalOperationFaultCountMetrics).join("+"),
            label: props.service.serviceName + " fault count",
            period: props.service.period
        });
        this.regionalFaultCountServerSideAlarm = new aws_cloudwatch_1.Alarm(this, "RegionalFaultCount", {
            alarmName: aws_cdk_lib_1.Fn.ref("AWS::Region") + "-" + props.service.serviceName.toLowerCase() + "-fault-count",
            datapointsToAlarm: 3,
            evaluationPeriods: 5,
            comparisonOperator: aws_cloudwatch_1.ComparisonOperator.GREATER_THAN_THRESHOLD,
            threshold: props.service.faultCountThreshold,
            alarmDescription: "Counts faults from all critical operation in the service",
            metric: regionalFaultCount
        });
        let canaryAlarms = Object.values(Object.entries(props.perOperationAlarmsAndRules)
            .reduce((filtered, [key, value]) => {
            if (criticalOperations.indexOf(key) > -1) {
                filtered[key] = value;
            }
            return filtered;
        }, {})).reduce((filtered, value) => {
            if (value.canaryRegionalAlarmsAndRules !== undefined) {
                filtered.push(value.canaryRegionalAlarmsAndRules);
            }
            return filtered;
        }, [])
            .map(x => x.availabilityOrLatencyAlarm);
        if (canaryAlarms !== undefined && canaryAlarms !== null && canaryAlarms.length > 0) {
            this.regionalAvailabilityCanaryAlarm = new aws_cloudwatch_1.CompositeAlarm(this, "ServiceCanaryAggregateIsolatedImpactAlarm", {
                compositeAlarmName: aws_cdk_lib_1.Fn.ref("AWS::Region") + "-" + props.service.serviceName.toLowerCase() + "-canary-aggregate-alarm",
                alarmRule: aws_cloudwatch_1.AlarmRule.anyOf(...canaryAlarms)
            });
        }
        this.regionalAvailabilityServerSideAlarm = new aws_cloudwatch_1.CompositeAlarm(this, "ServiceServerSideAggregateIsolatedImpactAlarm", {
            compositeAlarmName: aws_cdk_lib_1.Fn.ref("AWS::Region") + "-" + props.service.serviceName.toLowerCase() + "-server-side-aggregate-alarm",
            alarmRule: aws_cloudwatch_1.AlarmRule.anyOf(...Object.values(Object.entries(props.perOperationAlarmsAndRules)
                .reduce((filtered, [key, value]) => {
                if (criticalOperations.indexOf(key) > -1) {
                    filtered[key] = value;
                }
                return filtered;
            }, {}))
                .map(x => x.serverSideRegionalAlarmsAndRules)
                .map(x => x.availabilityOrLatencyAlarm))
        });
    }
}
exports.ServiceAlarmsAndRules = ServiceAlarmsAndRules;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VydmljZUFsYXJtc0FuZFJ1bGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiU2VydmljZUFsYXJtc0FuZFJ1bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJDQUF1QztBQUl2QyxpRkFBaUY7QUFDakYsK0RBQW1JO0FBQ25JLHFJQUFxSTtBQUNySSw0RkFBeUY7QUFDekYsZ0ZBQTZFO0FBQzdFLDZDQUFpQztBQUlqQyxnRkFBNkU7QUFFN0U7O0dBRUc7QUFDSCxNQUFhLHFCQUFzQixTQUFRLHNCQUFTO0lBNkJoRCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQWlDO1FBRXZFLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakIsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO1FBRTdCLElBQUksa0JBQWtCLEdBQWEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDeEgsSUFBSSxPQUFPLEdBQVcsQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxrQ0FBa0MsR0FBRyxFQUFFLENBQUM7UUFFN0MsSUFBSSxRQUFRLEdBQTRCLElBQUksK0NBQXNCLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRTtZQUNqRixxQkFBcUIsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLHFCQUFxQjtTQUM3RCxDQUFDLENBQUM7UUFFSCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQ25FLENBQUM7WUFDRyxJQUFJLG1CQUFtQixHQUFXLFFBQVEsQ0FBQyxr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dHNcIjtcbmltcG9ydCB7IElPcGVyYXRpb25BbGFybXNBbmRSdWxlcyB9IGZyb20gXCIuL0lPcGVyYXRpb25BbGFybXNBbmRSdWxlc1wiO1xuaW1wb3J0IHsgSVNlcnZpY2VBbGFybXNBbmRSdWxlcyB9IGZyb20gXCIuL0lTZXJ2aWNlQWxhcm1zQW5kUnVsZXNcIjtcbmltcG9ydCB7IFNlcnZpY2VBbGFybXNBbmRSdWxlc1Byb3BzIH0gZnJvbSBcIi4vcHJvcHMvU2VydmljZUFsYXJtc0FuZFJ1bGVzUHJvcHNcIjtcbi8vaW1wb3J0IHsgQWxhcm1SdWxlLCBDb21wb3NpdGVBbGFybSwgSUFsYXJtIH0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1jbG91ZHdhdGNoXCI7XG5pbXBvcnQgeyBBbGFybSwgQWxhcm1SdWxlLCBDb21wYXJpc29uT3BlcmF0b3IsIENvbXBvc2l0ZUFsYXJtLCBJQWxhcm0sIElNZXRyaWMsIE1hdGhFeHByZXNzaW9uIH0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1jbG91ZHdhdGNoXCI7XG4vL2ltcG9ydCB7IEFsYXJtLCBBbGFybVJ1bGUsIENvbXBhcmlzb25PcGVyYXRvciwgQ29tcG9zaXRlQWxhcm0sIElBbGFybSwgSU1ldHJpYywgTWF0aEV4cHJlc3Npb24gfSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWNsb3Vkd2F0Y2hcIjtcbmltcG9ydCB7IEF2YWlsYWJpbGl0eUFuZExhdGVuY3lNZXRyaWNzIH0gZnJvbSBcIi4uL21ldHJpY3MvQXZhaWxhYmlsaXR5QW5kTGF0ZW5jeU1ldHJpY3NcIjtcbmltcG9ydCB7IEF2YWlsYWJpbGl0eU1ldHJpY1R5cGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL0F2YWlsYWJpbGl0eU1ldHJpY1R5cGVcIjtcbmltcG9ydCB7IEZuIH0gZnJvbSBcImF3cy1jZGstbGliXCI7XG5pbXBvcnQgeyBJU2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlcy9JU2VydmljZVwiO1xuaW1wb3J0IHsgSUNhbmFyeU9wZXJhdGlvblJlZ2lvbmFsQWxhcm1zQW5kUnVsZXMgfSBmcm9tIFwiLi9JQ2FuYXJ5T3BlcmF0aW9uUmVnaW9uYWxBbGFybXNBbmRSdWxlc1wiO1xuaW1wb3J0IHsgSUF2YWlsYWJpbGl0eVpvbmVNYXBwZXIgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL0lBdmFpbGFiaWxpdHlab25lTWFwcGVyXCI7XG5pbXBvcnQgeyBBdmFpbGFiaWxpdHlab25lTWFwcGVyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9BdmFpbGFiaWxpdHlab25lTWFwcGVyXCI7XG5cbi8qKlxuICogU2VydmljZSBsZXZlbCBhbGFybXMgYW5kIHJ1bGVzIHVzaW5nIGNyaXRpY2FsIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFNlcnZpY2VBbGFybXNBbmRSdWxlcyBleHRlbmRzIENvbnN0cnVjdCBpbXBsZW1lbnRzIElTZXJ2aWNlQWxhcm1zQW5kUnVsZXNcbntcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmljZSB0aGVzZSBhbGFybXMgYW5kIHJ1bGVzIGFyZSBmb3JcbiAgICAgKi9cbiAgICBzZXJ2aWNlOiBJU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB6b25hbCBhZ2dyZWdhdGUgaXNvbGF0ZWQgaW1wYWN0IGFsYXJtcy4gVGhlcmUgaXMgMSBhbGFybSBwZXIgQVogdGhhdFxuICAgICAqIHRyaWdnZXJzIGZvciBhdmFpbGFiaWxpdHkgb3IgbGF0ZW5jeSBpbXBhY3QgdG8gYW55IGNyaXRpY2FsIG9wZXJhdGlvbiBpbiB0aGF0IEFaIFxuICAgICAqIHRoYXQgaW5kaWNhdGVzIGl0IGhhcyBpc29sYXRlZCBpbXBhY3QgYXMgbWVhc3VyZWQgYnkgY2FuYXJpZXMgb3Igc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgem9uYWxBZ2dyZWdhdGVJc29sYXRlZEltcGFjdEFsYXJtczogSUFsYXJtW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbGFybSBmb3IgcmVnaW9uYWwgaW1wYWN0IG9mIGFueSBjcml0aWNhbCBvcGVyYXRpb24gYXMgbWVhc3VyZWQgYnkgdGhlIGNhbmFyeS5cbiAgICAgKi9cbiAgICByZWdpb25hbEF2YWlsYWJpbGl0eUNhbmFyeUFsYXJtPzogSUFsYXJtO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxhcm0gZm9yIHJlZ2lvbmFsIGltcGFjdCBvZiBhbnkgY3JpdGljYWwgb3BlcmF0aW9uIGFzIG1lYXN1cmVkIGJ5IHRoZSBzZXJ2ZXItc2lkZS5cbiAgICAgKi9cbiAgICByZWdpb25hbEF2YWlsYWJpbGl0eVNlcnZlclNpZGVBbGFybTogSUFsYXJtO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxhcm0gZm9yIGZhdWx0IGNvdW50IGV4Y2VlZGluZyBhIHJlZ2lvbmFsIHRocmVzaG9sZCBmb3IgYWxsIGNyaXRpY2FsIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcmVnaW9uYWxGYXVsdENvdW50U2VydmVyU2lkZUFsYXJtOiBJQWxhcm07XG5cbiAgICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogU2VydmljZUFsYXJtc0FuZFJ1bGVzUHJvcHMpXG4gICAge1xuICAgICAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBwcm9wcy5zZXJ2aWNlO1xuXG4gICAgICAgIGxldCBjcml0aWNhbE9wZXJhdGlvbnM6IHN0cmluZ1tdID0gcHJvcHMuc2VydmljZS5vcGVyYXRpb25zLmZpbHRlcih4ID0+IHguaXNDcml0aWNhbCA9PSB0cnVlKS5tYXAoeCA9PiB4Lm9wZXJhdGlvbk5hbWUpO1xuICAgICAgICBsZXQgY291bnRlcjogbnVtYmVyID0gMTtcbiAgICAgICAgdGhpcy56b25hbEFnZ3JlZ2F0ZUlzb2xhdGVkSW1wYWN0QWxhcm1zID0gW107XG5cbiAgICAgICAgbGV0IGF6TWFwcGVyOiBJQXZhaWxhYmlsaXR5Wm9uZU1hcHBlciA9IG5ldyBBdmFpbGFiaWxpdHlab25lTWFwcGVyKHRoaXMsIFwiQVpNYXBwZXJcIiwge1xuICAgICAgICAgICAgYXZhaWxhYmlsaXR5Wm9uZU5hbWVzOiBwcm9wcy5zZXJ2aWNlLmF2YWlsYWJpbGl0eVpvbmVOYW1lc1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMuc2VydmljZS5hdmFpbGFiaWxpdHlab25lTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBhdmFpbGFiaWxpdHlab25lZElkOiBzdHJpbmcgPSBhek1hcHBlci5hdmFpbGFiaWxpdHlab25lSWQocHJvcHMuc2VydmljZS5hdmFpbGFiaWxpdHlab25lTmFtZXNbaV0pO1xuXG4gICAgICAgICAgICB0aGlzLnpvbmFsQWdncmVnYXRlSXNvbGF0ZWRJbXBhY3RBbGFybXMucHVzaChuZXcgQ29tcG9zaXRlQWxhcm0odGhpcywgXCJBWlwiICsgY291bnRlciArIFwiU2VydmljZUFnZ3JlZ2F0ZUlzb2xhdGVkSW1wYWN0QWxhcm1cIiwge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZUFsYXJtTmFtZTogYXZhaWxhYmlsaXR5Wm9uZWRJZCArIFwiLVwiICsgcHJvcHMuc2VydmljZS5zZXJ2aWNlTmFtZS50b0xvd2VyQ2FzZSgpICsgXCItaXNvbGF0ZWQtaW1wYWN0LWFnZ3JlZ2F0ZS1hbGFybVwiLFxuICAgICAgICAgICAgICAgIGFsYXJtUnVsZTogQWxhcm1SdWxlLmFueU9mKC4uLk9iamVjdC52YWx1ZXMoT2JqZWN0LmVudHJpZXMocHJvcHMucGVyT3BlcmF0aW9uQWxhcm1zQW5kUnVsZXMpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGZpbHRlcmVkLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcml0aWNhbE9wZXJhdGlvbnMuaW5kZXhPZihrZXkpID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9IGFzIHtba2V5OiBzdHJpbmddOiBJT3BlcmF0aW9uQWxhcm1zQW5kUnVsZXN9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAubWFwKHggPT4geC5hZ2dyZWdhdGVab25hbEFsYXJtc1tpXSkpXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWdpb25hbEF2YWlsYWJpbGl0eVNlcnZlclNpZGVBbGFybSA9IG5ldyBDb21wb3NpdGVBbGFybSh0aGlzLCBcInRlc1RcIiwge1xuICAgICAgICAgICAgYWxhcm1SdWxlOiBBbGFybVJ1bGUuZnJvbVN0cmluZyhcIkFMQVJNKFRFU1QpXCIpXG4gICAgICAgIH0pOyBcbiAgICAgICBcbiAgICAgICAgbGV0IGtleVByZWZpeDogc3RyaW5nID0gXCJcIjtcblxuICAgICAgICBsZXQgcmVnaW9uYWxPcGVyYXRpb25GYXVsdENvdW50TWV0cmljczoge1trZXk6IHN0cmluZ106IElNZXRyaWN9ID0ge307XG5cbiAgICAgICAgcHJvcHMuc2VydmljZS5vcGVyYXRpb25zLmZpbHRlcih4ID0+IHguaXNDcml0aWNhbCA9PSB0cnVlKS5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAga2V5UHJlZml4ID0gQXZhaWxhYmlsaXR5QW5kTGF0ZW5jeU1ldHJpY3MubmV4dENoYXIoa2V5UHJlZml4KTtcblxuICAgICAgICAgICAgcmVnaW9uYWxPcGVyYXRpb25GYXVsdENvdW50TWV0cmljc1trZXlQcmVmaXhdID0gQXZhaWxhYmlsaXR5QW5kTGF0ZW5jeU1ldHJpY3MuY3JlYXRlUmVnaW9uYWxBdmFpbGFiaWxpdHlNZXRyaWMoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiB4Lm9wZXJhdGlvbk5hbWUgKyBcIiBmYXVsdCBjb3VudFwiLFxuICAgICAgICAgICAgICAgIG1ldHJpY0RldGFpbHM6IHguc2VydmVyU2lkZUF2YWlsYWJpbGl0eU1ldHJpY0RldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0cmljVHlwZTogQXZhaWxhYmlsaXR5TWV0cmljVHlwZS5GQVVMVF9DT1VOVFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCByZWdpb25hbEZhdWx0Q291bnQ6IElNZXRyaWMgPSBuZXcgTWF0aEV4cHJlc3Npb24oe1xuICAgICAgICAgICAgdXNpbmdNZXRyaWNzOiByZWdpb25hbE9wZXJhdGlvbkZhdWx0Q291bnRNZXRyaWNzLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogT2JqZWN0LmtleXMocmVnaW9uYWxPcGVyYXRpb25GYXVsdENvdW50TWV0cmljcykuam9pbihcIitcIiksXG4gICAgICAgICAgICBsYWJlbDogcHJvcHMuc2VydmljZS5zZXJ2aWNlTmFtZSArIFwiIGZhdWx0IGNvdW50XCIsXG4gICAgICAgICAgICBwZXJpb2Q6IHByb3BzLnNlcnZpY2UucGVyaW9kXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVnaW9uYWxGYXVsdENvdW50U2VydmVyU2lkZUFsYXJtID0gbmV3IEFsYXJtKHRoaXMsIFwiUmVnaW9uYWxGYXVsdENvdW50XCIsIHtcbiAgICAgICAgICAgIGFsYXJtTmFtZTogRm4ucmVmKFwiQVdTOjpSZWdpb25cIikgKyBcIi1cIiArIHByb3BzLnNlcnZpY2Uuc2VydmljZU5hbWUudG9Mb3dlckNhc2UoKSArIFwiLWZhdWx0LWNvdW50XCIsXG4gICAgICAgICAgICBkYXRhcG9pbnRzVG9BbGFybTogMyxcbiAgICAgICAgICAgIGV2YWx1YXRpb25QZXJpb2RzOiA1LFxuICAgICAgICAgICAgY29tcGFyaXNvbk9wZXJhdG9yOiBDb21wYXJpc29uT3BlcmF0b3IuR1JFQVRFUl9USEFOX1RIUkVTSE9MRCxcbiAgICAgICAgICAgIHRocmVzaG9sZDogcHJvcHMuc2VydmljZS5mYXVsdENvdW50VGhyZXNob2xkLFxuICAgICAgICAgICAgYWxhcm1EZXNjcmlwdGlvbjogXCJDb3VudHMgZmF1bHRzIGZyb20gYWxsIGNyaXRpY2FsIG9wZXJhdGlvbiBpbiB0aGUgc2VydmljZVwiLFxuICAgICAgICAgICAgbWV0cmljOiByZWdpb25hbEZhdWx0Q291bnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNhbmFyeUFsYXJtczogSUFsYXJtW10gPSBPYmplY3QudmFsdWVzKE9iamVjdC5lbnRyaWVzKHByb3BzLnBlck9wZXJhdGlvbkFsYXJtc0FuZFJ1bGVzKVxuICAgICAgICAucmVkdWNlKChmaWx0ZXJlZCwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3JpdGljYWxPcGVyYXRpb25zLmluZGV4T2Yoa2V5KSA+IC0xKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgICAgICB9LCB7fSBhcyB7W2tleTogc3RyaW5nXTogSU9wZXJhdGlvbkFsYXJtc0FuZFJ1bGVzfSkpLnJlZHVjZSgoZmlsdGVyZWQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuY2FuYXJ5UmVnaW9uYWxBbGFybXNBbmRSdWxlcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2godmFsdWUuY2FuYXJ5UmVnaW9uYWxBbGFybXNBbmRSdWxlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICAgICAgfSwgW10gYXMgSUNhbmFyeU9wZXJhdGlvblJlZ2lvbmFsQWxhcm1zQW5kUnVsZXNbXSlcbiAgICAgICAgLm1hcCh4ID0+IHguYXZhaWxhYmlsaXR5T3JMYXRlbmN5QWxhcm0pO1xuXG5cbiAgICAgICAgaWYgKGNhbmFyeUFsYXJtcyAhPT0gdW5kZWZpbmVkICYmIGNhbmFyeUFsYXJtcyAhPT0gbnVsbCAmJiBjYW5hcnlBbGFybXMubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZWdpb25hbEF2YWlsYWJpbGl0eUNhbmFyeUFsYXJtID0gbmV3IENvbXBvc2l0ZUFsYXJtKHRoaXMsIFwiU2VydmljZUNhbmFyeUFnZ3JlZ2F0ZUlzb2xhdGVkSW1wYWN0QWxhcm1cIiwge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZUFsYXJtTmFtZTogRm4ucmVmKFwiQVdTOjpSZWdpb25cIikgKyBcIi1cIiArIHByb3BzLnNlcnZpY2Uuc2VydmljZU5hbWUudG9Mb3dlckNhc2UoKSArIFwiLWNhbmFyeS1hZ2dyZWdhdGUtYWxhcm1cIixcbiAgICAgICAgICAgICAgICBhbGFybVJ1bGU6IEFsYXJtUnVsZS5hbnlPZiguLi5jYW5hcnlBbGFybXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWdpb25hbEF2YWlsYWJpbGl0eVNlcnZlclNpZGVBbGFybSA9IG5ldyBDb21wb3NpdGVBbGFybSh0aGlzLCBcIlNlcnZpY2VTZXJ2ZXJTaWRlQWdncmVnYXRlSXNvbGF0ZWRJbXBhY3RBbGFybVwiLCB7XG4gICAgICAgICAgICBjb21wb3NpdGVBbGFybU5hbWU6IEZuLnJlZihcIkFXUzo6UmVnaW9uXCIpICsgXCItXCIgKyBwcm9wcy5zZXJ2aWNlLnNlcnZpY2VOYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi1zZXJ2ZXItc2lkZS1hZ2dyZWdhdGUtYWxhcm1cIixcbiAgICAgICAgICAgIGFsYXJtUnVsZTogQWxhcm1SdWxlLmFueU9mKC4uLk9iamVjdC52YWx1ZXMoT2JqZWN0LmVudHJpZXMocHJvcHMucGVyT3BlcmF0aW9uQWxhcm1zQW5kUnVsZXMpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoZmlsdGVyZWQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3JpdGljYWxPcGVyYXRpb25zLmluZGV4T2Yoa2V5KSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICAgICAgICAgICAgfSwge30gYXMge1trZXk6IHN0cmluZ106IElPcGVyYXRpb25BbGFybXNBbmRSdWxlc30pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKHggPT4geC5zZXJ2ZXJTaWRlUmVnaW9uYWxBbGFybXNBbmRSdWxlcylcbiAgICAgICAgICAgIC5tYXAoeCA9PiB4LmF2YWlsYWJpbGl0eU9yTGF0ZW5jeUFsYXJtKVxuICAgICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICB9XG59Il19